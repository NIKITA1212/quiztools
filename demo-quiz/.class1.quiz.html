<!-- --- begin quiz --- -->

<p>
<!-- --- begin quiz question --- -->
What kind of mathematical functions are best implemented as a class?
<!-- --- end quiz question --- -->

<p>
<!-- --- begin quiz choice 1 (wrong) --- -->
Linear functions
<!-- --- end quiz choice 1 (wrong) --- -->

<p>
<!-- --- begin explanation of choice 1 --- -->
A class is very suitable for mathematical functions with parameters (in addition to one or more independent variables), because one then avoids to have the parameters as global variables.
<!-- --- end explanation of choice 1 --- -->

<p>
<!-- --- begin quiz choice 2 (wrong) --- -->
Polynomials
<!-- --- end quiz choice 2 (wrong) --- -->

<p>
<!-- --- begin explanation of choice 2 --- -->
A class is very suitable for mathematical functions with parameters (in addition to one or more independent variables), because one then avoids to have the parameters as global variables.
<!-- --- end explanation of choice 2 --- -->

<p>
<!-- --- begin quiz choice 3 (wrong) --- -->
Trigonometric functions
<!-- --- end quiz choice 3 (wrong) --- -->

<p>
<!-- --- begin explanation of choice 3 --- -->
A class is very suitable for mathematical functions with parameters (in addition to one or more independent variables), because one then avoids to have the parameters as global variables.
<!-- --- end explanation of choice 3 --- -->

<p>
<!-- --- begin quiz choice 4 (right) --- -->
Functions with parameters in addition to independent variable(s)
<!-- --- end quiz choice 4 (right) --- -->

<p>
<!-- --- begin explanation of choice 4 --- -->
A class is very suitable for mathematical functions with parameters (in addition to one or more independent variables), because one then avoids to have the parameters as global variables.
<!-- --- end explanation of choice 4 --- -->

<p>
<!-- --- begin quiz choice 5 (wrong) --- -->
Functions that need <code>if</code> tests
<!-- --- end quiz choice 5 (wrong) --- -->

<p>
<!-- --- begin explanation of choice 5 --- -->
A class is very suitable for mathematical functions with parameters (in addition to one or more independent variables), because one then avoids to have the parameters as global variables.
<!-- --- end explanation of choice 5 --- -->

<p>
<!-- --- begin quiz choice 6 (wrong) --- -->
Mathematically beautiful functions with a touch of class
<!-- --- end quiz choice 6 (wrong) --- -->

<p>
<!-- --- begin explanation of choice 6 --- -->
A class is very suitable for mathematical functions with parameters (in addition to one or more independent variables), because one then avoids to have the parameters as global variables.
<!-- --- end explanation of choice 6 --- -->
<!-- --- end quiz --- -->

<!-- --- begin quiz --- -->

<p>
<!-- --- begin quiz question --- -->
What is the name of the constructor in a Python class?
<!-- --- end quiz question --- -->

<p>
<!-- --- begin quiz choice 1 (wrong) --- -->
<code>value</code>
<!-- --- end quiz choice 1 (wrong) --- -->

<p>
<!-- --- begin explanation of choice 1 --- -->
<code>value</code> has nothing to do with a constructor.
<!-- --- end explanation of choice 1 --- -->

<p>
<!-- --- begin quiz choice 2 (right) --- -->
<code>__init__</code>
<!-- --- end quiz choice 2 (right) --- -->

<p>
<!-- --- begin explanation of choice 2 --- -->
The constructor must always be called <code>__init__</code>.
<!-- --- end explanation of choice 2 --- -->

<p>
<!-- --- begin quiz choice 3 (wrong) --- -->
<code>__call__</code>
<!-- --- end quiz choice 3 (wrong) --- -->

<p>
<!-- --- begin explanation of choice 3 --- -->
<code>__call__</code> is not the constructor, it is used to make instances callable as ordinary Python functions.
<!-- --- end explanation of choice 3 --- -->
<!-- --- end quiz --- -->

<!-- --- begin quiz --- -->

<p>
<!-- --- begin quiz question --- -->
Which statement is wrong?
<!-- --- end quiz question --- -->

<p>
<!-- --- begin quiz choice 1 (wrong) --- -->
Any class method must have <code>self</code> as first argument.
<!-- --- end quiz choice 1 (wrong) --- -->

<p>
<!-- --- begin explanation of choice 1 --- -->
This statement is correct, but the name <code>self</code> is just a convention - any name will do.
<!-- --- end explanation of choice 1 --- -->

<p>
<!-- --- begin quiz choice 2 (wrong) --- -->
<code>self</code> is dropped as argument in calls to class methods.
<!-- --- end quiz choice 2 (wrong) --- -->

<p>
<!-- --- begin explanation of choice 2 --- -->
This statements is correct, Python will feed in the instance object automatically as <code>self</code> in any method.
<!-- --- end explanation of choice 2 --- -->

<p>
<!-- --- begin quiz choice 3 (right) --- -->
<code>self</code> is a reserved word in Python.
<!-- --- end quiz choice 3 (right) --- -->

<p>
<!-- --- begin explanation of choice 3 --- -->
Wrong because <code>self</code> is just a naming convention of an instances of the current class - other languages use <code>this</code> instead (as a reserved word). Any name instead of <code>self</code> can be used, but it is a convention to use <code>self</code>.
<!-- --- end explanation of choice 3 --- -->

<p>
<!-- --- begin quiz choice 4 (wrong) --- -->
<code>self</code> is used to give various parts of a class access to common attributes and methods
<!-- --- end quiz choice 4 (wrong) --- -->

<p>
<!-- --- begin explanation of choice 4 --- -->
This statement is correct.
<!-- --- end explanation of choice 4 --- -->
<!-- --- end quiz --- -->

<!-- --- begin quiz --- -->

<p>
<!-- --- begin quiz question --- -->
Which of the following statements is false?
<!-- --- end quiz question --- -->

<p>
<!-- --- begin quiz choice 1 (wrong) --- -->
An object of a class is called an instance
<!-- --- end quiz choice 1 (wrong) --- -->

<p>
<!-- --- begin explanation of choice 1 --- -->
This statement is correct.
<!-- --- end explanation of choice 1 --- -->

<p>
<!-- --- begin quiz choice 2 (wrong) --- -->
A function in a class is called a method
<!-- --- end quiz choice 2 (wrong) --- -->

<p>
<!-- --- begin explanation of choice 2 --- -->
This statement is correct.
<!-- --- end explanation of choice 2 --- -->

<p>
<!-- --- begin quiz choice 3 (wrong) --- -->
A variable in a class is called an attribute
<!-- --- end quiz choice 3 (wrong) --- -->

<p>
<!-- --- begin explanation of choice 3 --- -->
This statement is correct.
<!-- --- end explanation of choice 3 --- -->

<p>
<!-- --- begin quiz choice 4 (wrong) --- -->
The <code>__init__</code> method is called constructor
<!-- --- end quiz choice 4 (wrong) --- -->

<p>
<!-- --- begin explanation of choice 4 --- -->
This statement is correct.
<!-- --- end explanation of choice 4 --- -->

<p>
<!-- --- begin quiz choice 5 (right) --- -->
Attributes must be defined in the constructor
<!-- --- end quiz choice 5 (right) --- -->

<p>
<!-- --- begin explanation of choice 5 --- -->
False, attributes can be defined in any method and even outside the class in the calling program.
<!-- --- end explanation of choice 5 --- -->

<p>
<!-- --- begin quiz choice 6 (wrong) --- -->
<code>self</code> is the first argument in methods, but never used in method calls
<!-- --- end quiz choice 6 (wrong) --- -->

<p>
<!-- --- begin explanation of choice 6 --- -->
This statement is correct.
<!-- --- end explanation of choice 6 --- -->

<p>
<!-- --- begin quiz choice 7 (wrong) --- -->
<code>self</code> is a reference to the instance of the class that was used in the call to a method
<!-- --- end quiz choice 7 (wrong) --- -->

<p>
<!-- --- begin explanation of choice 7 --- -->
This statement is correct.
<!-- --- end explanation of choice 7 --- -->
<!-- --- end quiz --- -->

<!-- --- begin quiz --- -->

<p>
<!-- --- begin quiz question --- -->
What is a doc string?
<!-- --- end quiz question --- -->

<p>
<!-- --- begin quiz choice 1 (wrong) --- -->
A document that is read into a Python string with <code>f.read()</code>
<!-- --- end quiz choice 1 (wrong) --- -->

<p>
<!-- --- begin explanation of choice 1 --- -->
No, a doc string is used to document code.
<!-- --- end explanation of choice 1 --- -->

<p>
<!-- --- begin quiz choice 2 (wrong) --- -->
A string enclosed in triple double quotes
<!-- --- end quiz choice 2 (wrong) --- -->

<p>
<!-- --- begin explanation of choice 2 --- -->
Doc strings are by convention enclosed in triple double quotes, but not all strings enclosed in this type of quotes are doc strings! And doc strings can be enclosed in any type of quotes - triple double quotes is just a common convention.
<!-- --- end explanation of choice 2 --- -->

<p>
<!-- --- begin quiz choice 3 (right) --- -->
The first string after a class or function definition, or the first string in a module file. The purpose of the string is to document the function/class/module.
<!-- --- end quiz choice 3 (right) --- -->

<p>
<!-- --- begin explanation of choice 3 --- -->
Correct.
<!-- --- end explanation of choice 3 --- -->

<p>
<!-- --- begin quiz choice 4 (wrong) --- -->
A statement made by a person with a doctorate degree
<!-- --- end quiz choice 4 (wrong) --- -->

<p>
<!-- --- begin explanation of choice 4 --- -->
This is nonsense.
<!-- --- end explanation of choice 4 --- -->
<!-- --- end quiz --- -->

<!-- --- begin quiz --- -->

<p>
<!-- --- begin quiz question --- -->
What is the convention for writing a doc string in Python?
<!-- --- end quiz question --- -->

<p>
<!-- --- begin quiz choice 1 (wrong) --- -->
Double quotes and brief listing of keywords regarding the function/class.
<!-- --- end quiz choice 1 (wrong) --- -->

<p>
<!-- --- begin explanation of choice 1 --- -->
The convention for writing doc strings in Python is to use triple double quotes and full phrases.
<!-- --- end explanation of choice 1 --- -->

<p>
<!-- --- begin quiz choice 2 (wrong) --- -->
Simple quotes and complete phrases (capital letter and full stop)
<!-- --- end quiz choice 2 (wrong) --- -->

<p>
<!-- --- begin explanation of choice 2 --- -->
The convention for writing doc strings in Python is to use triple double quotes and full phrases.
<!-- --- end explanation of choice 2 --- -->

<p>
<!-- --- begin quiz choice 3 (wrong) --- -->
Triple double quotes around an interactive example showing how to use the class/function
<!-- --- end quiz choice 3 (wrong) --- -->

<p>
<!-- --- begin explanation of choice 3 --- -->
The convention for writing doc strings in Python is to use triple double quotes and full phrases. Interactive examples are fine, but not a convention, just a suggested option when it makes sense.
<!-- --- end explanation of choice 3 --- -->

<p>
<!-- --- begin quiz choice 4 (right) --- -->
Triple double quotes and complete phrases (capital letter and full stop)
<!-- --- end quiz choice 4 (right) --- -->

<p>
<!-- --- begin explanation of choice 4 --- -->
Correct.
<!-- --- end explanation of choice 4 --- -->
<!-- --- end quiz --- -->

<!-- --- begin quiz --- -->

<p>
<!-- --- begin quiz question --- -->
Class methods having names starting and ending with a double underscore are called:
<!-- --- end quiz question --- -->

<p>
<!-- --- begin quiz choice 1 (wrong) --- -->
class methods
<!-- --- end quiz choice 1 (wrong) --- -->

<p>
<!-- --- begin explanation of choice 1 --- -->
Class methods having names starting and ending with a double underscore are called special methods.
<!-- --- end explanation of choice 1 --- -->

<p>
<!-- --- begin quiz choice 2 (wrong) --- -->
constructor methods
<!-- --- end quiz choice 2 (wrong) --- -->

<p>
<!-- --- begin explanation of choice 2 --- -->
Class methods having names starting and ending with a double underscore are called special methods.
<!-- --- end explanation of choice 2 --- -->

<p>
<!-- --- begin quiz choice 3 (wrong) --- -->
static methods
<!-- --- end quiz choice 3 (wrong) --- -->

<p>
<!-- --- begin explanation of choice 3 --- -->
Class methods having names starting and ending with a double underscore are called special methods.
<!-- --- end explanation of choice 3 --- -->

<p>
<!-- --- begin quiz choice 4 (right) --- -->
special methods
<!-- --- end quiz choice 4 (right) --- -->

<p>
<!-- --- begin explanation of choice 4 --- -->
Class methods having names starting and ending with a double underscore are called special methods.
<!-- --- end explanation of choice 4 --- -->
<!-- --- end quiz --- -->

<!-- --- begin quiz --- -->

<p>
<!-- --- begin quiz question --- -->
How can we check if a class <code>Y</code> holds the variable <code>v0</code>?
<!-- --- end quiz question --- -->

<p>
<!-- --- begin quiz choice 1 (wrong) --- -->
<code>Y.find('v0')</code>
<!-- --- end quiz choice 1 (wrong) --- -->

<p>
<!-- --- begin explanation of choice 1 --- -->
To check if a class contains the attribute <code>v0</code>, we can use the Python function <code>hasattr</code>.
<!-- --- end explanation of choice 1 --- -->

<p>
<!-- --- begin quiz choice 2 (wrong) --- -->
<code>search('Y', 'v0')</code>
<!-- --- end quiz choice 2 (wrong) --- -->

<p>
<!-- --- begin explanation of choice 2 --- -->
To check if a class contains the attribute <code>v0</code>, we can use the Python function <code>hasattr</code>.
<!-- --- end explanation of choice 2 --- -->

<p>
<!-- --- begin quiz choice 3 (right) --- -->
<code>hasattr(self, 'v0')</code>
<!-- --- end quiz choice 3 (right) --- -->

<p>
<!-- --- begin explanation of choice 3 --- -->
To check if a class contains the attribute <code>v0</code>, we can use the Python function <code>hasattr</code>.
<!-- --- end explanation of choice 3 --- -->

<p>
<!-- --- begin quiz choice 4 (wrong) --- -->
<code>isinstance(v0, Y)</code>
<!-- --- end quiz choice 4 (wrong) --- -->

<p>
<!-- --- begin explanation of choice 4 --- -->
This checks if <code>v0</code> is of type <code>Y</code>, <code>hasattr</code> is the right function to use here.
<!-- --- end explanation of choice 4 --- -->
<!-- --- end quiz --- -->

<!-- --- begin quiz --- -->

<p>
<!-- --- begin quiz question --- -->
What is the difference between <code>__str__</code> and <code>__repr__</code>?
<!-- --- end quiz question --- -->

<p>
<!-- --- begin quiz choice 1 (right) --- -->
<code>__str__</code> usually returns a pretty print of the instance while <code>__repr__</code> usually returns a string that works with <code>eval</code> to recreate the instance
<!-- --- end quiz choice 1 (right) --- -->

<p>
<!-- --- begin explanation of choice 1 --- -->
<code>__str__</code> usually returns a pretty print of the instance while <code>__repr__</code> usually returns a string that works with <code>eval</code> to recreate the instance.
<!-- --- end explanation of choice 1 --- -->

<p>
<!-- --- begin quiz choice 2 (wrong) --- -->
No difference, <code>__repr__</code> is a synonym for <code>__str__</code>
<!-- --- end quiz choice 2 (wrong) --- -->

<p>
<!-- --- begin explanation of choice 2 --- -->
<code>__str__</code> usually returns a pretty print of the instance while <code>__repr__</code> usually returns a string that works with <code>eval</code> to recreate the instance.
<!-- --- end explanation of choice 2 --- -->

<p>
<!-- --- begin quiz choice 3 (wrong) --- -->
<code>__str__</code> converts the instance to a string, while <code>__repr__</code> repairs a broken instance
<!-- --- end quiz choice 3 (wrong) --- -->

<p>
<!-- --- begin explanation of choice 3 --- -->
<code>__str__</code> usually returns a pretty print of the instance while <code>__repr__</code> usually returns a string that works with <code>eval</code> to recreate the instance.
<!-- --- end explanation of choice 3 --- -->

<p>
<!-- --- begin quiz choice 4 (wrong) --- -->
<code>__str__</code> is a legal special method name while <code>__repr__</code> is an illegal name
<!-- --- end quiz choice 4 (wrong) --- -->

<p>
<!-- --- begin explanation of choice 4 --- -->
<code>__str__</code> usually returns a pretty print of the instance while <code>__repr__</code> usually returns a string that works with <code>eval</code> to recreate the instance.
<!-- --- end explanation of choice 4 --- -->
<!-- --- end quiz --- -->

<!-- --- begin quiz --- -->

<p>
<!-- --- begin quiz question --- -->
How can we define a local (or non-public) method that is meant to be called other methods in the class only and not by users of the class?
<!-- --- end quiz question --- -->

<p>
<!-- --- begin quiz choice 1 (wrong) --- -->
By using the keyword <code>local</code> as in <code>local mymethod(...)</code>
<!-- --- end quiz choice 1 (wrong) --- -->

<p>
<!-- --- begin explanation of choice 1 --- -->
There is no <code>local</code> keyword in Python.
<!-- --- end explanation of choice 1 --- -->

<p>
<!-- --- begin quiz choice 2 (right) --- -->
By using an underscore as a prefix: <code>_mymethod</code>
<!-- --- end quiz choice 2 (right) --- -->

<p>
<!-- --- begin explanation of choice 2 --- -->
Correct, methods starting with an underscore are local/private/non-public to the class and not meant to be called outside the class.
<!-- --- end explanation of choice 2 --- -->

<p>
<!-- --- begin quiz choice 3 (wrong) --- -->
By using the keyword <code>private</code> before the method name
<!-- --- end quiz choice 3 (wrong) --- -->

<p>
<!-- --- begin explanation of choice 3 --- -->
There is no <code>private</code> keyword in Python.
<!-- --- end explanation of choice 3 --- -->

<p>
<!-- --- begin quiz choice 4 (wrong) --- -->
By using the keyword <code>protected</code> before the method name
<!-- --- end quiz choice 4 (wrong) --- -->

<p>
<!-- --- begin explanation of choice 4 --- -->
There is no keyword <code>protected</code> in Python - a method name starting with an underscore is what corresponds to <code>protected</code> in other languages.
<!-- --- end explanation of choice 4 --- -->

<p>
<!-- --- begin quiz choice 5 (wrong) --- -->
By using the keyword <code>nonpublic</code> before the method name
<!-- --- end quiz choice 5 (wrong) --- -->

<p>
<!-- --- begin explanation of choice 5 --- -->
There is no keyword `nonpublic in Python.
<!-- --- end explanation of choice 5 --- -->
<!-- --- end quiz --- -->

<!-- --- begin quiz --- -->

<p>
<!-- --- begin quiz question --- -->
The boolean expression <code>a == b</code> can lead to unintended results when
<!-- --- end quiz question --- -->

<p>
<!-- --- begin quiz choice 1 (right) --- -->
<code>a</code> and <code>b</code> are two floating point numbers
<!-- --- end quiz choice 1 (right) --- -->

<p>
<!-- --- begin explanation of choice 1 --- -->
A floating-point number may be subject to round-off errors. Two mathematically equal numbers may be different in their inexact representations on the computer, which will make the result of a test <code>if a == b</code> is <code>False</code> when the test would have been <code>True</code> in exact mathematics.
<!-- --- end explanation of choice 1 --- -->

<p>
<!-- --- begin quiz choice 2 (wrong) --- -->
<code>a</code> and <code>b</code> are of two different types
<!-- --- end quiz choice 2 (wrong) --- -->

<p>
<!-- --- begin explanation of choice 2 --- -->
<code>a</code> and <code>b</code> can be of different types if <code>a</code>'s type (class) has a special method <code>__eq__</code> which allows an argument of another type (and this might well be the case - the programmer of <code>a</code>'s type is in charge of what <code>__eq__</code> does).
<!-- --- end explanation of choice 2 --- -->

<p>
<!-- --- begin quiz choice 3 (wrong) --- -->
<code>a</code> and <code>b</code> are instances of a user-defined class
<!-- --- end quiz choice 3 (wrong) --- -->

<p>
<!-- --- begin explanation of choice 3 --- -->
No, this works fine if the class has an <code>__eq__</code> special method. If not, <code>a == b</code> still works, but the outcome might be unintended.
<!-- --- end explanation of choice 3 --- -->
<!-- --- end quiz --- -->

<!-- --- begin quiz --- -->

<p>
<!-- --- begin quiz question --- -->
When is it natural to use a class?
<!-- --- end quiz question --- -->

<p>
<!-- --- begin quiz choice 1 (wrong) --- -->
When noble statements are of a high class
<!-- --- end quiz choice 1 (wrong) --- -->

<p>
<!-- --- begin explanation of choice 1 --- -->
Python programs are always high class.
<!-- --- end explanation of choice 1 --- -->

<p>
<!-- --- begin quiz choice 2 (right) --- -->
When a set of variables and functions naturally belong together and should be viewed as one unit
<!-- --- end quiz choice 2 (right) --- -->

<p>
<!-- --- begin explanation of choice 2 --- -->
This is correct.
<!-- --- end explanation of choice 2 --- -->

<p>
<!-- --- begin quiz choice 3 (wrong) --- -->
When you want a simple program to look difficult
<!-- --- end quiz choice 3 (wrong) --- -->

<p>
<!-- --- begin explanation of choice 3 --- -->
Class-based programs usually looks simpler than function-based programs unless the program is very short.
<!-- --- end explanation of choice 3 --- -->

<p>
<!-- --- begin quiz choice 4 (wrong) --- -->
When you want to show others that you are an advanced programmer
<!-- --- end quiz choice 4 (wrong) --- -->

<p>
<!-- --- begin explanation of choice 4 --- -->
Most programmers master the class concept so it takes more than classes to convince others that you are an advanced programmer.
<!-- --- end explanation of choice 4 --- -->

<p>
<!-- --- begin quiz choice 5 (wrong) --- -->
When a program needs global variables
<!-- --- end quiz choice 5 (wrong) --- -->

<p>
<!-- --- begin explanation of choice 5 --- -->
Classes can sometimes avoid global variables, but the presence of global variables is not always a good indication of the need for classes.
<!-- --- end explanation of choice 5 --- -->

<p>
<!-- --- begin quiz choice 6 (wrong) --- -->
When you lack <code>self</code> confidence
<!-- --- end quiz choice 6 (wrong) --- -->

<p>
<!-- --- begin explanation of choice 6 --- -->
Almost correct - if you lack confidence in the <code>self</code> argument it is smart to program more classes to understand what <code>self</code> is and get improve your self confidence.
<!-- --- end explanation of choice 6 --- -->
<!-- --- end quiz --- -->

